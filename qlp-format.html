<script>
  // ...código acima inalterado...

  let rawData;
  let isDate1904 = false; // <- vamos detectar isso ao carregar

  // ======== CONVERSOR DE DATA SEM DESVIO (respeita 1900/1904) ========
  function excelSerialToBRDate(serial) {
    if (serial == null || serial === '') return '';

    // Se for 1904, Excel armazena 1462 dias a menos
    const n = isDate1904 ? (Number(serial) + 1462) : Number(serial);

    // Usa o parser do xlsx: evita timezone e lida com o bug de 1900
    const dc = XLSX.SSF.parse_date_code(n);
    if (!dc) return '';

    const dd = String(dc.d).padStart(2, '0');
    const mm = String(dc.m).padStart(2, '0');
    const yy = dc.y;
    return `${dd}/${mm}/${yy}`;
  }

  function handleFile(e){
    const files = e.target.files;
    if(!files.length) return;

    const reader = new FileReader();
    reader.onload = (ev)=>{
      const data = new Uint8Array(ev.target.result);
      const wb = XLSX.read(data, { type:'array', cellDates:false, raw:true });

      // Detecta se o workbook usa sistema 1904
      isDate1904 = !!(wb?.Workbook?.WBProps?.date1904);

      const ws = wb.Sheets[wb.SheetNames[0]];
      rawData = XLSX.utils.sheet_to_json(ws, { header:1, raw:true }); // mantém números crus
      displayColumnSelectionModal();
    };
    reader.readAsArrayBuffer(files[0]);
  }

  function processAndDownloadData(data, columnsToKeep, newHeaders, unitName){
    if (data.length <= 4){ alert('O arquivo não tem linhas suficientes para serem processadas.'); return; }
    const dataRows = data.slice(4);

    // Lotes 46 mantém / 5 pula (seu padrão)
    let finalRows = [], keep=0, skip=0;
    for (let i=0;i<dataRows.length;i++){
      if (keep<46){ finalRows.push(dataRows[i]); keep++; }
      else if (skip<5){ skip++; }
      if (skip===5){ keep=0; skip=0; }
    }

    const totalRowIndex = finalRows.findIndex(row => row[0] && String(row[0]).toLowerCase().includes('total'));
    if (totalRowIndex !== -1) finalRows = finalRows.slice(0,totalRowIndex);

    const findOriginalIndex = name => (headerMapping.find(m=>m.newName===name)?.originalIndex ?? -1);
    const vinculoIdx     = findOriginalIndex('VINCULO');
    const situacaoIdx    = findOriginalIndex('SITUACAO');
    const filialIdx      = findOriginalIndex('FILIAL');
    const cpfIdx         = findOriginalIndex('CPF');
    const pisIdx         = findOriginalIndex('PIS');
    const admissaoIdx    = findOriginalIndex('ADMISSAO');
    const nascimentoIdx  = findOriginalIndex('NASCIMENTO');

    const formatted = finalRows.map(row=>{
      const newRow = [];
      columnsToKeep.forEach(colIdx=>{
        let cell = row[colIdx] ?? '';

        // (demais mapeamentos iguais aos seus...)

        // CPF
        if (colIdx === cpfIdx){
          let cpf = String(cell).replace(/\D/g,'').padStart(11,'0');
          if (cpf.length===11) cell = cpf.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/,'$1.$2.$3-$4');
        }

        // PIS
        if (colIdx === pisIdx){
          let pis = String(cell).replace(/\D/g,'').padStart(11,'0');
          if (pis.length===11) cell = pis.replace(/(\d{3})(\d{5})(\d{2})(\d{1})/,'$1.$2.$3-$4');
        }

        // DATAS (sem fuso e respeitando 1904)
        if (colIdx===admissaoIdx || colIdx===nascimentoIdx){
          if (typeof cell === 'number') {
            cell = excelSerialToBRDate(cell);
          } else if (typeof cell === 'string') {
            // tenta normalizar strings comuns (dd/mm/aaaa ou aaaa-mm-dd)
            const s = cell.trim();
            const m1 = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
            const m2 = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s);
            if (m1) {
              const dd = m1[1].padStart(2,'0'), mm=m1[2].padStart(2,'0'), yy=m1[3];
              cell = `${dd}/${mm}/${yy}`;
            } else if (m2) {
              const dd = m2[3].padStart(2,'0'), mm=m2[2].padStart(2,'0'), yy=m2[1];
              cell = `${dd}/${mm}/${yy}`;
            } // senão, deixa como está
          }
        }

        newRow.push(cell);
      });
      return newRow;
    });

    formatted.unshift(newHeaders);
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(formatted);
    XLSX.utils.book_append_sheet(wb, ws, 'Planilha Formatada');

    const fileName = `QLP - ${unitName || 'PlanilhaFormatada'}.xlsx`;
    XLSX.writeFile(wb, fileName);
    fileInput.value = null;
  }
</script>
